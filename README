int is_spelled_correctly(const char *word, char **dictionary, int dictionary_size) {
    for (int i = 0; i < dictionary_size; i++) {
        if (strcmp(dictionary[i], word) == 0) {
            return 1; // Word found in dictionary
        }
    }

    return 0; // Word not found in dictionary
}

int spellchecker(char* filename, char *dictionary[], int numWords){
    int fd;
    char buffer[BUFFER_SIZE];
    ssize_t bytesRead;
    int lineNumber = 1;
    int charNumber = 1;
    char *word = NULL;
    int wordLength = 0;

    // Open the file
    fd = open(filename, O_RDONLY);
    if (fd == -1) {
        perror("Error opening the file.\n");
        return 1;
    }

    // Read characters from the file
    while ((bytesRead = read(fd, buffer, BUFFER_SIZE)) > 0) {
        for (ssize_t i = 0; i < bytesRead; i++) {
            char ch = buffer[i];
            // Check for newline character
            if (ch == '\n') {
                // Increment line number and reset character number
                lineNumber++;
                charNumber = 1;
            } else if (ch == ' ' || ch == '\t' || ch == '\r' || ch=='\n') {
                // Word boundary found, store the word if it's not empty
                if (wordLength > 0) {
                    // Allocate memory for the word and copy it
                    word = (char *)malloc((wordLength + 1) * sizeof(char));
                    if (word == NULL) {
                        perror("Memory allocation error.\n");
                        close(fd);
                        return 1;
                    }
                    strncpy(word, &buffer[i - wordLength], wordLength);
                    word[wordLength] = '\0'; // Null-terminate the string
                    // Print the word along with line and character number
                    int search = 0;
                    for(int j = 0; j < numWords; j++) {
                        if (!is_spelled_correctly(word, dictionary, numWords)) {
                            search = 1;
                            break;
                        }
                    }
                    if(search == 0) {
                        printf("%s (%d, %d): %s\n", filename, lineNumber, charNumber - wordLength, word);     
                    }
                    // Free allocated memory
                    free(word);
                    wordLength = 0; // Reset word length
                }
            } else {
                // Non-space character, increment character number
                charNumber++;
                wordLength++; // Increment word length
            }
        }
    }

    // Check for read error
    if (bytesRead == -1) {
        perror("Error reading from the file.\n");
        close(fd);
        return 1;
    }

    // Close the file
    close(fd);

    return 0;
}

void traverse_directory(const char *dirname, char **dictionary, int dictionary_size) {
    DIR *dir = opendir(dirname);
    if (dir == NULL) {
        perror("failed opening directory");
        return;
    }

    struct dirent *entry;
    while ((entry = readdir(dir)) != NULL) {
        if (strcmp(entry->d_name, ".") == 0 || strcmp(entry->d_name, "..") == 0)
            continue;

        char filePath[maxPathLength];
        snprintf(filePath, maxPathLength, "%s/%s", dirname, entry->d_name);

        struct stat pathStat;
        if (stat(filePath, &pathStat) == 0) {
            if (S_ISDIR(pathStat.st_mode)) {
                traverse_directory(filePath, dictionary, dictionary_size);
            } else if (S_ISREG(pathStat.st_mode)) {
                char *dot = strrchr(entry->d_name, '.');
                if (dot != NULL && strcmp(dot, ".txt") == 0) {
                    spellchecker(filePath, dictionary, dictionary_size);
                }
            }
        } else {
            perror("File status failed.");
        }
    }

    closedir(dir);
}